{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nclass EasyTyper {\n  constructor(obj, input, fn, hooks) {\n    checkKeyIsNull(obj);\n    checkFieldIsError(obj);\n    this.obj = obj;\n    this.input = typeof input === 'string' ? [input] : input;\n    this.fn = typeof fn === 'function' ? fn : function () {};\n    this.hooks = typeof hooks === 'function' ? hooks : function () {};\n    this.timer = 0;\n    this.typeAction = {\n      rollback: this.typedBack.bind(this),\n      normal: this.play.bind(this),\n      custom: this.fn\n    }; // 实例化完后立即执行打字输出\n\n    this.init();\n  } // 初始化\n\n\n  init() {\n    this.play();\n  } // 打字\n\n\n  play() {\n    if (!this.input.length) return this.fn(this);\n    let i = 0,\n        stop = false,\n        input = this.input.shift() || '';\n    this.timer = setInterval(() => {\n      if (i === input.length) {\n        i = 0;\n        stop = true;\n        this.closeTimer();\n      }\n\n      if (this.obj.isEnd) return this.closeTimer();\n      if (stop) return this.nextTick();\n      this.obj.output = input.slice(0, i + 1);\n      this.hooks(input.slice(0, i + 1), this);\n      i++;\n    }, this.obj.speed);\n  } // 回滚方法\n\n\n  typedBack() {\n    // 如果句子出书完毕，且是句子暂停模式\n    if (!this.input.length && this.obj.sentencePause) return this.fn(this);\n    let input = this.obj.output;\n    let i = input.length,\n        stop = false;\n    this.timer = setInterval(() => {\n      if (i === -1) {\n        this.obj.output = '';\n        this.hooks('', this);\n        i = 0;\n        stop = true;\n        this.closeTimer();\n      }\n\n      if (this.obj.isEnd) {\n        this.closeTimer();\n        return this.obj.singleBack = false;\n      }\n\n      if (stop) {\n        this.obj.singleBack = false;\n        return (() => {\n          const {\n            length\n          } = this.input;\n          return length ? this.play() : this.fn(this);\n        })();\n      }\n\n      this.obj.output = input.slice(0, i + 1);\n      this.hooks(input.slice(0, i + 1), this);\n      i--;\n    }, this.obj.backSpeed);\n  } // 下一次触发方式\n\n\n  nextTick() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // 等待\n      yield this.sleep(this.obj.sleep);\n      return this.obj.singleBack ? this.typedBack() : this.getOutputType();\n    });\n  } // 输出方式\n\n\n  getOutputType() {\n    return this.typeAction[this.obj.type](this);\n  } // 关闭定时器\n\n\n  closeTimer() {\n    clearInterval(this.timer);\n  } // 线程等待\n\n\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  } // 结束\n\n\n  close() {\n    return this.obj.isEnd = true;\n  }\n\n} // 错误提示语\n\n\nconst errorTip = message => {\n  throw new Error(message);\n}; // 校验参数完整性\n\n\nconst checkKeyIsNull = obj => {\n  const props = {\n    output: '',\n    type: '',\n    isEnd: false,\n    speed: 80,\n    backSpeed: 40,\n    sleep: 3000,\n    singleBack: false,\n    sentencePause: false\n  };\n  const propsKeys = Object.keys(props);\n  const objKeys = Object.keys(obj);\n\n  if (propsKeys.length !== objKeys.length) {\n    errorTip('配置对象错误: 字段数量不正确！');\n  }\n\n  propsKeys.forEach(key => {\n    if (obj[key] === undefined || obj[key] === null) {\n      errorTip('配置对象错误：字段值为null或undefined！');\n    }\n  });\n}; // 检验参数类型\n\n\nconst checkFieldIsError = obj => {\n  Object.keys(obj).forEach(key => {\n    const proxy = EasyTyperStrategy[key](obj);\n\n    if (proxy.check()) {\n      proxy.showTip(key);\n    }\n  });\n}; // 策略分发\n\n\nconst EasyTyperStrategy = (() => ({\n  output: obj => {\n    return new CheckField(`string`, obj.output);\n  },\n  type: obj => {\n    return new CheckField(`string`, obj.type);\n  },\n  isEnd: obj => {\n    return new CheckField(`boolean`, obj.isEnd);\n  },\n  speed: obj => {\n    return new CheckField(`number`, obj.speed);\n  },\n  backSpeed: obj => {\n    return new CheckField(`number`, obj.backSpeed);\n  },\n  sleep: obj => {\n    return new CheckField(`number`, obj.sleep);\n  },\n  singleBack: obj => {\n    return new CheckField(`boolean`, obj.singleBack);\n  },\n  sentencePause: obj => {\n    return new CheckField(`boolean`, obj.sentencePause);\n  }\n}))(); // 字段校验类\n\n\nclass CheckField {\n  constructor(type, field) {\n    this.type = type;\n    this.field = field;\n  }\n\n  check() {\n    return typeof this.field !== `${this.type}`;\n  }\n\n  showTip(name) {\n    errorTip(`配置对象错误：属性 ${name} 必须为 ${this.type} 类型！`);\n  }\n\n}\n\nexport default EasyTyper;","map":null,"metadata":{},"sourceType":"module"}